/*
 * generated by Xtext 2.10.0
 */
package sar.drone.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sar.drone.drn.And;
import sar.drone.drn.Assignement;
import sar.drone.drn.Attribut;
import sar.drone.drn.BACKWARD;
import sar.drone.drn.CARREXY;
import sar.drone.drn.CARREYZ;
import sar.drone.drn.CERCLEXY;
import sar.drone.drn.CERCLEYZ;
import sar.drone.drn.Camera;
import sar.drone.drn.Context;
import sar.drone.drn.DOWN;
import sar.drone.drn.Declaration;
import sar.drone.drn.Definition;
import sar.drone.drn.DepXY;
import sar.drone.drn.DepXYZ;
import sar.drone.drn.DepXZ;
import sar.drone.drn.DepYZ;
import sar.drone.drn.Device;
import sar.drone.drn.DrnPackage;
import sar.drone.drn.Element;
import sar.drone.drn.FORWARD;
import sar.drone.drn.Flip;
import sar.drone.drn.InitialDirection;
import sar.drone.drn.InitialPositionX;
import sar.drone.drn.InitialPositionY;
import sar.drone.drn.LEFT;
import sar.drone.drn.Land;
import sar.drone.drn.LedBlink;
import sar.drone.drn.Led_Impl;
import sar.drone.drn.MaxHeigth;
import sar.drone.drn.MaxLength;
import sar.drone.drn.MaxSpeed;
import sar.drone.drn.MaxWidth;
import sar.drone.drn.Model;
import sar.drone.drn.Parametre;
import sar.drone.drn.RIGHT;
import sar.drone.drn.RefDevice;
import sar.drone.drn.RefPart;
import sar.drone.drn.Rotate;
import sar.drone.drn.TakeOff;
import sar.drone.drn.TypeGeneric;
import sar.drone.drn.UP;
import sar.drone.drn.Wait;
import sar.drone.drn.With;
import sar.drone.services.DrnGrammarAccess;

@SuppressWarnings("all")
public class DrnSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DrnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DrnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DrnPackage.AND:
				if (rule == grammarAccess.getAndRule()) {
					sequence_And(context, (And) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_And_Expression(context, (And) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case DrnPackage.ATTRIBUT:
				sequence_Attribut(context, (Attribut) semanticObject); 
				return; 
			case DrnPackage.BACKWARD:
				if (rule == grammarAccess.getDepY_ImplRule()
						|| rule == grammarAccess.getBACKWARDRule()) {
					sequence_BACKWARD(context, (BACKWARD) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_BACKWARD_Expression(context, (BACKWARD) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.CARREXY:
				if (rule == grammarAccess.getDepXY_IMPLRule()
						|| rule == grammarAccess.getCARREXYRule()) {
					sequence_CARREXY(context, (CARREXY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_CARREXY_Expression(context, (CARREXY) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.CARREYZ:
				if (rule == grammarAccess.getDepYZ_IMPLRule()
						|| rule == grammarAccess.getCARREYZRule()) {
					sequence_CARREYZ(context, (CARREYZ) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_CARREYZ_Expression(context, (CARREYZ) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.CERCLEXY:
				if (rule == grammarAccess.getDepXY_IMPLRule()
						|| rule == grammarAccess.getCERCLEXYRule()) {
					sequence_CERCLEXY(context, (CERCLEXY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_CERCLEXY_Expression(context, (CERCLEXY) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.CERCLEYZ:
				if (rule == grammarAccess.getDepYZ_IMPLRule()
						|| rule == grammarAccess.getCERCLEYZRule()) {
					sequence_CERCLEYZ(context, (CERCLEYZ) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_CERCLEYZ_Expression(context, (CERCLEYZ) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.CAMERA:
				sequence_Camera(context, (Camera) semanticObject); 
				return; 
			case DrnPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case DrnPackage.DOWN:
				if (rule == grammarAccess.getDepZ_ImplRule()
						|| rule == grammarAccess.getDOWNRule()) {
					sequence_DOWN(context, (DOWN) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_DOWN_Expression(context, (DOWN) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case DrnPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case DrnPackage.DEP_XY:
				if (rule == grammarAccess.getDepXY_IMPLRule()
						|| rule == grammarAccess.getDepXYRule()) {
					sequence_DepXY(context, (DepXY) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_DepXY_Expression(context, (DepXY) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.DEP_XYZ:
				if (rule == grammarAccess.getDepXYZ_IMPLRule()
						|| rule == grammarAccess.getDepXYZRule()) {
					sequence_DepXYZ(context, (DepXYZ) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_DepXYZ_Expression(context, (DepXYZ) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.DEP_XZ:
				if (rule == grammarAccess.getDepXZ_IMPLRule()
						|| rule == grammarAccess.getDepXZRule()) {
					sequence_DepXZ(context, (DepXZ) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_DepXZ_Expression(context, (DepXZ) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.DEP_YZ:
				if (rule == grammarAccess.getDepYZ_IMPLRule()
						|| rule == grammarAccess.getDepYZRule()) {
					sequence_DepYZ(context, (DepYZ) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_DepYZ_Expression(context, (DepYZ) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case DrnPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case DrnPackage.FORWARD:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_FORWARD(context, (FORWARD) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDepY_ImplRule()
						|| rule == grammarAccess.getFORWARDRule()) {
					sequence_FORWARD(context, (FORWARD) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.FLIP:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_Flip(context, (Flip) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDepXYZ_IMPLRule()
						|| rule == grammarAccess.getFlipRule()) {
					sequence_Flip(context, (Flip) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.INITIAL_DIRECTION:
				sequence_InitialDirection(context, (InitialDirection) semanticObject); 
				return; 
			case DrnPackage.INITIAL_POSITION_X:
				sequence_InitialPositionX(context, (InitialPositionX) semanticObject); 
				return; 
			case DrnPackage.INITIAL_POSITION_Y:
				sequence_InitialPositionY(context, (InitialPositionY) semanticObject); 
				return; 
			case DrnPackage.LEFT:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_LEFT(context, (LEFT) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDepX_ImplRule()
						|| rule == grammarAccess.getLEFTRule()) {
					sequence_LEFT(context, (LEFT) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.LAND:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_Land(context, (Land) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLandRule()) {
					sequence_Land(context, (Land) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.LED_BLINK:
				sequence_LedBlink(context, (LedBlink) semanticObject); 
				return; 
			case DrnPackage.LED_IMPL:
				sequence_Led_Impl(context, (Led_Impl) semanticObject); 
				return; 
			case DrnPackage.MAX_HEIGTH:
				sequence_MaxHeigth(context, (MaxHeigth) semanticObject); 
				return; 
			case DrnPackage.MAX_LENGTH:
				sequence_MaxLength(context, (MaxLength) semanticObject); 
				return; 
			case DrnPackage.MAX_SPEED:
				sequence_MaxSpeed(context, (MaxSpeed) semanticObject); 
				return; 
			case DrnPackage.MAX_WIDTH:
				sequence_MaxWidth(context, (MaxWidth) semanticObject); 
				return; 
			case DrnPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DrnPackage.PARAMETRE:
				sequence_Parametre(context, (Parametre) semanticObject); 
				return; 
			case DrnPackage.RIGHT:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_RIGHT(context, (RIGHT) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDepX_ImplRule()
						|| rule == grammarAccess.getRIGHTRule()) {
					sequence_RIGHT(context, (RIGHT) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.REF_DEVICE:
				sequence_RefDevice(context, (RefDevice) semanticObject); 
				return; 
			case DrnPackage.REF_PART:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_RefPart(context, (RefPart) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRefPartRule()) {
					sequence_RefPart(context, (RefPart) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.ROTATE:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_Rotate(context, (Rotate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRotateRule()) {
					sequence_Rotate(context, (Rotate) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.TAKE_OFF:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_TakeOff(context, (TakeOff) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTakeOffRule()) {
					sequence_TakeOff(context, (TakeOff) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.TYPE_GENERIC:
				sequence_TypeGeneric(context, (TypeGeneric) semanticObject); 
				return; 
			case DrnPackage.UP:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_UP(context, (UP) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDepZ_ImplRule()
						|| rule == grammarAccess.getUPRule()) {
					sequence_UP(context, (UP) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.WAIT:
				if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression_Wait(context, (Wait) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWaitRule()) {
					sequence_Wait(context, (Wait) semanticObject); 
					return; 
				}
				else break;
			case DrnPackage.WITH:
				sequence_With(context, (With) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     And returns And
	 *
	 * Constraint:
	 *     (
	 *         name='merge' 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depz+=DepZ_Impl
	 *         ) 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depz+=DepZ_Impl
	 *         ) 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depz+=DepZ_Impl
	 *         )*
	 *     )
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *
	 * Constraint:
	 *     (
	 *         name='merge' 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depz+=DepZ_Impl
	 *         ) 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depz+=DepZ_Impl
	 *         ) 
	 *         rotate+=Rotate? 
	 *         ((depx+=DepX_Impl | depy+=DepY_Impl | depxz+=DepXZ_IMPL | depxy+=DepXY_IMPL | depz+=DepZ_Impl)? rotate+=Rotate?)* 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_And_Expression(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (name=ID (parametre+=Parametre parametre+=Parametre*)? operandes+=Expression operandes+=Expression*)
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribut returns Attribut
	 *
	 * Constraint:
	 *     (name=ID type=[TypeGeneric|ID] elmt+=[Element|ID])
	 */
	protected void sequence_Attribut(ISerializationContext context, Attribut semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepY_Impl returns BACKWARD
	 *     BACKWARD returns BACKWARD
	 *
	 * Constraint:
	 *     (name='backward' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_BACKWARD(ISerializationContext context, BACKWARD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BACKWARD
	 *
	 * Constraint:
	 *     (
	 *         name='backward' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_BACKWARD_Expression(ISerializationContext context, BACKWARD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepXY_IMPL returns CARREXY
	 *     CARREXY returns CARREXY
	 *
	 * Constraint:
	 *     (name='carreXY' (coteCST=EInt | coteVAR=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_CARREXY(ISerializationContext context, CARREXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CARREXY
	 *
	 * Constraint:
	 *     (
	 *         name='carreXY' 
	 *         (coteCST=EInt | coteVAR=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_CARREXY_Expression(ISerializationContext context, CARREXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepYZ_IMPL returns CARREYZ
	 *     CARREYZ returns CARREYZ
	 *
	 * Constraint:
	 *     (name='carreYZ' (coteCST=EInt | coteVAR=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_CARREYZ(ISerializationContext context, CARREYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CARREYZ
	 *
	 * Constraint:
	 *     (
	 *         name='carreYZ' 
	 *         (coteCST=EInt | coteVAR=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_CARREYZ_Expression(ISerializationContext context, CARREYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepXY_IMPL returns CERCLEXY
	 *     CERCLEXY returns CERCLEXY
	 *
	 * Constraint:
	 *     (name='cercleXY' (rayonCST=EInt | rayonVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_CERCLEXY(ISerializationContext context, CERCLEXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CERCLEXY
	 *
	 * Constraint:
	 *     (
	 *         name='cercleXY' 
	 *         (rayonCST=EInt | rayonVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_CERCLEXY_Expression(ISerializationContext context, CERCLEXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepYZ_IMPL returns CERCLEYZ
	 *     CERCLEYZ returns CERCLEYZ
	 *
	 * Constraint:
	 *     (name='cercleYZ' (rayonCST=EInt | rayonVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_CERCLEYZ(ISerializationContext context, CERCLEYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CERCLEYZ
	 *
	 * Constraint:
	 *     (
	 *         name='cercleYZ' 
	 *         (rayonCST=EInt | rayonVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_CERCLEYZ_Expression(ISerializationContext context, CERCLEYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Camera
	 *     Camera returns Camera
	 *
	 * Constraint:
	 *     (name='camera' mode=Mode attributs+=Attribut*)
	 */
	protected void sequence_Camera(ISerializationContext context, Camera semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     (name='CONTEXT' limit+=Limit limit+=Limit*)
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepZ_Impl returns DOWN
	 *     DOWN returns DOWN
	 *
	 * Constraint:
	 *     (name='down' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_DOWN(ISerializationContext context, DOWN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DOWN
	 *
	 * Constraint:
	 *     (
	 *         name='down' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_DOWN_Expression(ISerializationContext context, DOWN semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (type=[TypeGeneric|ID] name=ID)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclarationAccess().getTypeTypeGenericIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (left=[Declaration|ID] right=[Element|ID])
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEFINITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEFINITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEFINITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEFINITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionAccess().getLeftDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDefinitionAccess().getRightElementIDTerminalRuleCall_2_0_1(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DepXYZ_IMPL returns DepXYZ
	 *     DepXYZ returns DepXYZ
	 *
	 * Constraint:
	 *     (name='depXYZ' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_DepXYZ(ISerializationContext context, DepXYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DepXYZ
	 *
	 * Constraint:
	 *     (
	 *         name='depXYZ' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_DepXYZ_Expression(ISerializationContext context, DepXYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepXY_IMPL returns DepXY
	 *     DepXY returns DepXY
	 *
	 * Constraint:
	 *     (name='depXY' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_DepXY(ISerializationContext context, DepXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DepXY
	 *
	 * Constraint:
	 *     (
	 *         name='depXY' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_DepXY_Expression(ISerializationContext context, DepXY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepXZ_IMPL returns DepXZ
	 *     DepXZ returns DepXZ
	 *
	 * Constraint:
	 *     (name='depXZ' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_DepXZ(ISerializationContext context, DepXZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DepXZ
	 *
	 * Constraint:
	 *     (
	 *         name='depXZ' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_DepXZ_Expression(ISerializationContext context, DepXZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepYZ_IMPL returns DepYZ
	 *     DepYZ returns DepYZ
	 *
	 * Constraint:
	 *     (name='depYZ' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_DepYZ(ISerializationContext context, DepYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DepYZ
	 *
	 * Constraint:
	 *     (
	 *         name='depYZ' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_DepYZ_Expression(ISerializationContext context, DepYZ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Device
	 *
	 * Constraint:
	 *     (name=ID declarations+=Declaration declarations+=Declaration*)
	 */
	protected void sequence_Device(ISerializationContext context, Device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FORWARD
	 *
	 * Constraint:
	 *     (
	 *         name='forward' 
	 *         (distanceVar=[Parametre|ID] | distanceCST=EInt) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_FORWARD(ISerializationContext context, FORWARD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Flip
	 *
	 * Constraint:
	 *     (
	 *         name='flip' 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_Flip(ISerializationContext context, Flip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LEFT
	 *
	 * Constraint:
	 *     (
	 *         name='left' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_LEFT(ISerializationContext context, LEFT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Land
	 *
	 * Constraint:
	 *     (
	 *         name='land' 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_Land(ISerializationContext context, Land semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RIGHT
	 *
	 * Constraint:
	 *     (
	 *         name='right' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_RIGHT(ISerializationContext context, RIGHT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RefPart
	 *
	 * Constraint:
	 *     (
	 *         variable_partie=[Assignement|ID] 
	 *         params+=EInt* 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_RefPart(ISerializationContext context, RefPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Rotate
	 *
	 * Constraint:
	 *     (
	 *         name='rotate' 
	 *         (angleCST=EInt | angleVAR=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_Rotate(ISerializationContext context, Rotate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TakeOff
	 *
	 * Constraint:
	 *     (
	 *         name='takeoff' 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_TakeOff(ISerializationContext context, TakeOff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UP
	 *
	 * Constraint:
	 *     (
	 *         name='up' 
	 *         (distanceCST=EInt | distanceVar=[Parametre|ID]) 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_UP(ISerializationContext context, UP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Wait
	 *
	 * Constraint:
	 *     (
	 *         name='wait' 
	 *         (tempsCST=EInt | tempsVAR=[Parametre|ID]) 
	 *         (
	 *             ((repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?) | 
	 *             (then+=Expression then+=Expression* (repeatCST=EInt | repeatVAR=[Parametre|ID])? with+=With?)
	 *         )
	 *     )
	 */
	protected void sequence_Expression_Wait(ISerializationContext context, Wait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepY_Impl returns FORWARD
	 *     FORWARD returns FORWARD
	 *
	 * Constraint:
	 *     (name='forward' (distanceVar=[Parametre|ID] | distanceCST=EInt) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_FORWARD(ISerializationContext context, FORWARD semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepXYZ_IMPL returns Flip
	 *     Flip returns Flip
	 *
	 * Constraint:
	 *     name='flip'
	 */
	protected void sequence_Flip(ISerializationContext context, Flip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XYZ_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XYZ_IMPL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlipAccess().getNameFlipKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialDirection
	 *     InitialPosition returns InitialDirection
	 *     InitialDirection returns InitialDirection
	 *
	 * Constraint:
	 *     (name='initialDirection' value=DirectionType)
	 */
	protected void sequence_InitialDirection(ISerializationContext context, InitialDirection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_DIRECTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_DIRECTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialDirectionAccess().getNameInitialDirectionKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialDirectionAccess().getValueDirectionTypeEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialPositionX
	 *     InitialPosition returns InitialPositionX
	 *     InitialPositionX returns InitialPositionX
	 *
	 * Constraint:
	 *     (name='positionX' value=EInt)
	 */
	protected void sequence_InitialPositionX(ISerializationContext context, InitialPositionX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_POSITION_X__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_POSITION_X__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialPositionXAccess().getNamePositionXKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialPositionXAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialPositionY
	 *     InitialPosition returns InitialPositionY
	 *     InitialPositionY returns InitialPositionY
	 *
	 * Constraint:
	 *     (name='positionY' value=EInt)
	 */
	protected void sequence_InitialPositionY(ISerializationContext context, InitialPositionY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_POSITION_Y__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_POSITION_Y__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialPositionYAccess().getNamePositionYKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialPositionYAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DepX_Impl returns LEFT
	 *     LEFT returns LEFT
	 *
	 * Constraint:
	 *     (name='left' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_LEFT(ISerializationContext context, LEFT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Land returns Land
	 *
	 * Constraint:
	 *     name='land'
	 */
	protected void sequence_Land(ISerializationContext context, Land semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLandAccess().getNameLandKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns LedBlink
	 *     LedBlink returns LedBlink
	 *
	 * Constraint:
	 *     (name='ledBlink' mode=Mode color=ColorLed (blink_per_secCST=EInt | blink_per_secVAR=[Parametre|ID]) attributs+=Attribut*)
	 */
	protected void sequence_LedBlink(ISerializationContext context, LedBlink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Led_Impl
	 *     Led_Impl returns Led_Impl
	 *
	 * Constraint:
	 *     (name='led' mode=Mode color=ColorLed)
	 */
	protected void sequence_Led_Impl(ISerializationContext context, Led_Impl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LED_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LED_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.OPTION__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.OPTION__MODE));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LED_IMPL__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LED_IMPL__COLOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLed_ImplAccess().getNameLedKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLed_ImplAccess().getModeModeEnumRuleCall_4_0(), semanticObject.getMode());
		feeder.accept(grammarAccess.getLed_ImplAccess().getColorColorLedEnumRuleCall_7_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxHeigth
	 *     Surface returns MaxHeigth
	 *     MaxHeigth returns MaxHeigth
	 *
	 * Constraint:
	 *     (name='maxHeigth' value=EInt)
	 */
	protected void sequence_MaxHeigth(ISerializationContext context, MaxHeigth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxHeigthAccess().getNameMaxHeigthKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxHeigthAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxLength
	 *     Surface returns MaxLength
	 *     MaxLength returns MaxLength
	 *
	 * Constraint:
	 *     (name='maxLength' value=EInt)
	 */
	protected void sequence_MaxLength(ISerializationContext context, MaxLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxLengthAccess().getNameMaxLengthKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxLengthAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxSpeed
	 *     MaxSpeed returns MaxSpeed
	 *
	 * Constraint:
	 *     (name='maxSpeed' value=EInt)
	 */
	protected void sequence_MaxSpeed(ISerializationContext context, MaxSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.MAX_SPEED__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.MAX_SPEED__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxSpeedAccess().getNameMaxSpeedKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxSpeedAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxWidth
	 *     Surface returns MaxWidth
	 *     MaxWidth returns MaxWidth
	 *
	 * Constraint:
	 *     (name='maxWidth' value=EInt)
	 */
	protected void sequence_MaxWidth(ISerializationContext context, MaxWidth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxWidthAccess().getNameMaxWidthKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxWidthAccess().getValueEIntParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         context=Context? 
	 *         types+=TypeGeneric* 
	 *         devices+=Device* 
	 *         assignement+=Assignement 
	 *         assignement+=Assignement* 
	 *         main=RefPart
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parametre returns Parametre
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parametre(ISerializationContext context, Parametre semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.PARAMETRE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.PARAMETRE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParametreAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DepX_Impl returns RIGHT
	 *     RIGHT returns RIGHT
	 *
	 * Constraint:
	 *     (name='right' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_RIGHT(ISerializationContext context, RIGHT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns RefDevice
	 *     RefDevice returns RefDevice
	 *
	 * Constraint:
	 *     (dev=[Device|ID] mode=Mode definitions+=Definition*)
	 */
	protected void sequence_RefDevice(ISerializationContext context, RefDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefPart returns RefPart
	 *
	 * Constraint:
	 *     (variable_partie=[Assignement|ID] params+=EInt*)
	 */
	protected void sequence_RefPart(ISerializationContext context, RefPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rotate returns Rotate
	 *
	 * Constraint:
	 *     (name='rotate' (angleCST=EInt | angleVAR=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_Rotate(ISerializationContext context, Rotate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TakeOff returns TakeOff
	 *
	 * Constraint:
	 *     name='takeoff'
	 */
	protected void sequence_TakeOff(ISerializationContext context, TakeOff semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.TAKE_OFF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.TAKE_OFF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTakeOffAccess().getNameTakeoffKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeGeneric returns TypeGeneric
	 *
	 * Constraint:
	 *     (name=ID elements+=Element elements+=Element*)
	 */
	protected void sequence_TypeGeneric(ISerializationContext context, TypeGeneric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DepZ_Impl returns UP
	 *     UP returns UP
	 *
	 * Constraint:
	 *     (name='up' (distanceCST=EInt | distanceVar=[Parametre|ID]) (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_UP(ISerializationContext context, UP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Wait returns Wait
	 *
	 * Constraint:
	 *     (name='wait' (tempsCST=EInt | tempsVAR=[Parametre|ID]))
	 */
	protected void sequence_Wait(ISerializationContext context, Wait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     With returns With
	 *
	 * Constraint:
	 *     (name='with' option+=Option option+=Option*)
	 */
	protected void sequence_With(ISerializationContext context, With semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
