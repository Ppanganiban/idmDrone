/*
 * generated by Xtext 2.10.0
 */
package sar.drone.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import sar.drone.drn.And;
import sar.drone.drn.Assignement;
import sar.drone.drn.BACKWARD;
import sar.drone.drn.CARREXY;
import sar.drone.drn.CARREXZ;
import sar.drone.drn.CARREYZ;
import sar.drone.drn.CERCLEXY;
import sar.drone.drn.CERCLEXZ;
import sar.drone.drn.CERCLEYZ;
import sar.drone.drn.Context;
import sar.drone.drn.DOWN;
import sar.drone.drn.Declaration;
import sar.drone.drn.Definition;
import sar.drone.drn.Device;
import sar.drone.drn.DrnPackage;
import sar.drone.drn.Element;
import sar.drone.drn.Expression;
import sar.drone.drn.FORWARD;
import sar.drone.drn.Flip;
import sar.drone.drn.InitialDirection;
import sar.drone.drn.InitialPositionX;
import sar.drone.drn.InitialPositionY;
import sar.drone.drn.LEFT;
import sar.drone.drn.Land;
import sar.drone.drn.Library;
import sar.drone.drn.MaxHeight;
import sar.drone.drn.MaxLength;
import sar.drone.drn.MaxSpeed;
import sar.drone.drn.MaxWidth;
import sar.drone.drn.Model;
import sar.drone.drn.RIGHT;
import sar.drone.drn.RefDevice;
import sar.drone.drn.RefPart;
import sar.drone.drn.RefPartLib;
import sar.drone.drn.Rotate;
import sar.drone.drn.TakeOff;
import sar.drone.drn.TypeGeneric;
import sar.drone.drn.UP;
import sar.drone.drn.Wait;
import sar.drone.drn.With;
import sar.drone.services.DrnGrammarAccess;

@SuppressWarnings("all")
public class DrnSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DrnGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DrnPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DrnPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case DrnPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case DrnPackage.BACKWARD:
				sequence_BACKWARD(context, (BACKWARD) semanticObject); 
				return; 
			case DrnPackage.CARREXY:
				sequence_CARREXY(context, (CARREXY) semanticObject); 
				return; 
			case DrnPackage.CARREXZ:
				sequence_CARREXZ(context, (CARREXZ) semanticObject); 
				return; 
			case DrnPackage.CARREYZ:
				sequence_CARREYZ(context, (CARREYZ) semanticObject); 
				return; 
			case DrnPackage.CERCLEXY:
				sequence_CERCLEXY(context, (CERCLEXY) semanticObject); 
				return; 
			case DrnPackage.CERCLEXZ:
				sequence_CERCLEXZ(context, (CERCLEXZ) semanticObject); 
				return; 
			case DrnPackage.CERCLEYZ:
				sequence_CERCLEYZ(context, (CERCLEYZ) semanticObject); 
				return; 
			case DrnPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case DrnPackage.DOWN:
				sequence_DOWN(context, (DOWN) semanticObject); 
				return; 
			case DrnPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case DrnPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case DrnPackage.DEVICE:
				sequence_Device(context, (Device) semanticObject); 
				return; 
			case DrnPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case DrnPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case DrnPackage.FORWARD:
				sequence_FORWARD(context, (FORWARD) semanticObject); 
				return; 
			case DrnPackage.FLIP:
				sequence_Flip(context, (Flip) semanticObject); 
				return; 
			case DrnPackage.INITIAL_DIRECTION:
				sequence_InitialDirection(context, (InitialDirection) semanticObject); 
				return; 
			case DrnPackage.INITIAL_POSITION_X:
				sequence_InitialPositionX(context, (InitialPositionX) semanticObject); 
				return; 
			case DrnPackage.INITIAL_POSITION_Y:
				sequence_InitialPositionY(context, (InitialPositionY) semanticObject); 
				return; 
			case DrnPackage.LEFT:
				sequence_LEFT(context, (LEFT) semanticObject); 
				return; 
			case DrnPackage.LAND:
				sequence_Land(context, (Land) semanticObject); 
				return; 
			case DrnPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case DrnPackage.MAX_HEIGHT:
				sequence_MaxHeight(context, (MaxHeight) semanticObject); 
				return; 
			case DrnPackage.MAX_LENGTH:
				sequence_MaxLength(context, (MaxLength) semanticObject); 
				return; 
			case DrnPackage.MAX_SPEED:
				sequence_MaxSpeed(context, (MaxSpeed) semanticObject); 
				return; 
			case DrnPackage.MAX_WIDTH:
				sequence_MaxWidth(context, (MaxWidth) semanticObject); 
				return; 
			case DrnPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DrnPackage.RIGHT:
				sequence_RIGHT(context, (RIGHT) semanticObject); 
				return; 
			case DrnPackage.REF_DEVICE:
				sequence_RefDevice(context, (RefDevice) semanticObject); 
				return; 
			case DrnPackage.REF_PART:
				sequence_RefPart(context, (RefPart) semanticObject); 
				return; 
			case DrnPackage.REF_PART_LIB:
				sequence_RefPartLib(context, (RefPartLib) semanticObject); 
				return; 
			case DrnPackage.ROTATE:
				sequence_Rotate(context, (Rotate) semanticObject); 
				return; 
			case DrnPackage.TAKE_OFF:
				sequence_TakeOff(context, (TakeOff) semanticObject); 
				return; 
			case DrnPackage.TYPE_GENERIC:
				sequence_TypeGeneric(context, (TypeGeneric) semanticObject); 
				return; 
			case DrnPackage.UP:
				sequence_UP(context, (UP) semanticObject); 
				return; 
			case DrnPackage.WAIT:
				sequence_Wait(context, (Wait) semanticObject); 
				return; 
			case DrnPackage.WITH:
				sequence_With(context, (With) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Movement returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (
	 *         name='merge' 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depz+=DepZ_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depyz+=DepYZ_IMPL
	 *         ) 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depz+=DepZ_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depyz+=DepYZ_IMPL
	 *         ) 
	 *         (
	 *             rotate+=Rotate | 
	 *             depx+=DepX_Impl | 
	 *             depy+=DepY_Impl | 
	 *             depz+=DepZ_Impl | 
	 *             depxz+=DepXZ_IMPL | 
	 *             depxy+=DepXY_IMPL | 
	 *             depyz+=DepYZ_IMPL
	 *         )*
	 *     )
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (name=ID operandes+=Expression operandes+=Expression*)
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns BACKWARD
	 *     DepY_Impl returns BACKWARD
	 *     BACKWARD returns BACKWARD
	 *
	 * Constraint:
	 *     (name='backward' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_BACKWARD(ISerializationContext context, BACKWARD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBACKWARDAccess().getNameBackwardKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBACKWARDAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getBACKWARDAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CARREXY
	 *     DepXY_IMPL returns CARREXY
	 *     CARREXY returns CARREXY
	 *
	 * Constraint:
	 *     (name='carreXY' coteCST=INT tempsCST=INT)
	 */
	protected void sequence_CARREXY(ISerializationContext context, CARREXY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CARREXY__COTE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CARREXY__COTE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCARREXYAccess().getNameCarreXYKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCARREXYAccess().getCoteCSTINTTerminalRuleCall_4_0(), semanticObject.getCoteCST());
		feeder.accept(grammarAccess.getCARREXYAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CARREXZ
	 *     DepXZ_IMPL returns CARREXZ
	 *     CARREXZ returns CARREXZ
	 *
	 * Constraint:
	 *     (name='carreXZ' coteCST=INT tempsCST=INT)
	 */
	protected void sequence_CARREXZ(ISerializationContext context, CARREXZ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CARREXZ__COTE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CARREXZ__COTE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCARREXZAccess().getNameCarreXZKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCARREXZAccess().getCoteCSTINTTerminalRuleCall_4_0(), semanticObject.getCoteCST());
		feeder.accept(grammarAccess.getCARREXZAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CARREYZ
	 *     DepYZ_IMPL returns CARREYZ
	 *     CARREYZ returns CARREYZ
	 *
	 * Constraint:
	 *     (name='carreYZ' coteCST=INT tempsCST=INT)
	 */
	protected void sequence_CARREYZ(ISerializationContext context, CARREYZ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CARREYZ__COTE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CARREYZ__COTE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCARREYZAccess().getNameCarreYZKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCARREYZAccess().getCoteCSTINTTerminalRuleCall_4_0(), semanticObject.getCoteCST());
		feeder.accept(grammarAccess.getCARREYZAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CERCLEXY
	 *     DepXY_IMPL returns CERCLEXY
	 *     CERCLEXY returns CERCLEXY
	 *
	 * Constraint:
	 *     (name='cercleXY' rayonCST=INT tempsCST=INT)
	 */
	protected void sequence_CERCLEXY(ISerializationContext context, CERCLEXY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CERCLEXY__RAYON_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CERCLEXY__RAYON_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XY_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCERCLEXYAccess().getNameCercleXYKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCERCLEXYAccess().getRayonCSTINTTerminalRuleCall_4_0(), semanticObject.getRayonCST());
		feeder.accept(grammarAccess.getCERCLEXYAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CERCLEXZ
	 *     DepXZ_IMPL returns CERCLEXZ
	 *     CERCLEXZ returns CERCLEXZ
	 *
	 * Constraint:
	 *     (name='cercleXZ' rayonCST=INT tempsCST=INT)
	 */
	protected void sequence_CERCLEXZ(ISerializationContext context, CERCLEXZ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CERCLEXZ__RAYON_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CERCLEXZ__RAYON_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XZ_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCERCLEXZAccess().getNameCercleXZKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCERCLEXZAccess().getRayonCSTINTTerminalRuleCall_4_0(), semanticObject.getRayonCST());
		feeder.accept(grammarAccess.getCERCLEXZAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns CERCLEYZ
	 *     DepYZ_IMPL returns CERCLEYZ
	 *     CERCLEYZ returns CERCLEYZ
	 *
	 * Constraint:
	 *     (name='cercleYZ' rayonCST=INT tempsCST=INT)
	 */
	protected void sequence_CERCLEYZ(ISerializationContext context, CERCLEYZ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.CERCLEYZ__RAYON_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.CERCLEYZ__RAYON_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YZ_IMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCERCLEYZAccess().getNameCercleYZKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCERCLEYZAccess().getRayonCSTINTTerminalRuleCall_4_0(), semanticObject.getRayonCST());
		feeder.accept(grammarAccess.getCERCLEYZAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     (name='CONTEXT' limit+=Limit limit+=Limit*)
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns DOWN
	 *     DepZ_Impl returns DOWN
	 *     DOWN returns DOWN
	 *
	 * Constraint:
	 *     (name='down' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_DOWN(ISerializationContext context, DOWN semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDOWNAccess().getNameDownKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDOWNAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getDOWNAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     ((type=[TypeGeneric|ID] | typePrimitif=TypePrimitif) name=ID)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (left=[Declaration|ID] (right=[Element|ID] | real=EReal | int=EInt | bool=EBool | text=STRING))
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Device returns Device
	 *
	 * Constraint:
	 *     (name=ID declarations+=Declaration declarations+=Declaration*)
	 */
	protected void sequence_Device(ISerializationContext context, Device semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     ((move=Movement repeatCST=INT? with+=With?) | (move=Movement then+=Expression then+=Expression* repeatCST=INT? with+=With?))
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns FORWARD
	 *     DepY_Impl returns FORWARD
	 *     FORWARD returns FORWARD
	 *
	 * Constraint:
	 *     (name='forward' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_FORWARD(ISerializationContext context, FORWARD semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_YIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_YIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFORWARDAccess().getNameForwardKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFORWARDAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getFORWARDAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Flip
	 *     DepXYZ_IMPL returns Flip
	 *     Flip returns Flip
	 *
	 * Constraint:
	 *     name='flip'
	 */
	protected void sequence_Flip(ISerializationContext context, Flip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.FLIP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.FLIP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFlipAccess().getNameFlipKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialDirection
	 *     InitialPosition returns InitialDirection
	 *     InitialDirection returns InitialDirection
	 *
	 * Constraint:
	 *     (name='initialDirection' value=DirectionType)
	 */
	protected void sequence_InitialDirection(ISerializationContext context, InitialDirection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_DIRECTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_DIRECTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialDirectionAccess().getNameInitialDirectionKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialDirectionAccess().getValueDirectionTypeEnumRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialPositionX
	 *     InitialPosition returns InitialPositionX
	 *     InitialPositionX returns InitialPositionX
	 *
	 * Constraint:
	 *     (name='positionX' value=INT)
	 */
	protected void sequence_InitialPositionX(ISerializationContext context, InitialPositionX semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_POSITION_X__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_POSITION_X__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialPositionXAccess().getNamePositionXKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialPositionXAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns InitialPositionY
	 *     InitialPosition returns InitialPositionY
	 *     InitialPositionY returns InitialPositionY
	 *
	 * Constraint:
	 *     (name='positionY' value=INT)
	 */
	protected void sequence_InitialPositionY(ISerializationContext context, InitialPositionY semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.INITIAL_POSITION_Y__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.INITIAL_POSITION_Y__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialPositionYAccess().getNamePositionYKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInitialPositionYAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns LEFT
	 *     DepX_Impl returns LEFT
	 *     LEFT returns LEFT
	 *
	 * Constraint:
	 *     (name='left' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_LEFT(ISerializationContext context, LEFT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLEFTAccess().getNameLeftKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLEFTAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getLEFTAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Land
	 *     Land returns Land
	 *
	 * Constraint:
	 *     name='land'
	 */
	protected void sequence_Land(ISerializationContext context, Land semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLandAccess().getNameLandKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Root returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=ID types+=TypeGeneric* devices+=Device* assignement+=Assignement*)
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxHeight
	 *     Surface returns MaxHeight
	 *     MaxHeight returns MaxHeight
	 *
	 * Constraint:
	 *     (name='maxHeight' value=INT)
	 */
	protected void sequence_MaxHeight(ISerializationContext context, MaxHeight semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxHeightAccess().getNameMaxHeightKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxHeightAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxLength
	 *     Surface returns MaxLength
	 *     MaxLength returns MaxLength
	 *
	 * Constraint:
	 *     (name='maxLength' value=INT)
	 */
	protected void sequence_MaxLength(ISerializationContext context, MaxLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxLengthAccess().getNameMaxLengthKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxLengthAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxSpeed
	 *     MaxSpeed returns MaxSpeed
	 *
	 * Constraint:
	 *     (name='maxSpeed' value=INT)
	 */
	protected void sequence_MaxSpeed(ISerializationContext context, MaxSpeed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.MAX_SPEED__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.MAX_SPEED__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxSpeedAccess().getNameMaxSpeedKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxSpeedAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns MaxWidth
	 *     Surface returns MaxWidth
	 *     MaxWidth returns MaxWidth
	 *
	 * Constraint:
	 *     (name='maxWidth' value=INT)
	 */
	protected void sequence_MaxWidth(ISerializationContext context, MaxWidth semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.LIMIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.LIMIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.SURFACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.SURFACE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxWidthAccess().getNameMaxWidthKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMaxWidthAccess().getValueINTTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Root returns Model
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (libraries+=[Library|ID]* context=Context? assignement+=Assignement assignement+=Assignement* main=RefPart)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns RIGHT
	 *     DepX_Impl returns RIGHT
	 *     RIGHT returns RIGHT
	 *
	 * Constraint:
	 *     (name='right' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_RIGHT(ISerializationContext context, RIGHT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_XIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_XIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRIGHTAccess().getNameRightKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRIGHTAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getRIGHTAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefDevice returns RefDevice
	 *
	 * Constraint:
	 *     (dev=[Device|ID] mode=Mode definitions+=Definition*)
	 */
	protected void sequence_RefDevice(ISerializationContext context, RefDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns RefPartLib
	 *     RefPartLib returns RefPartLib
	 *
	 * Constraint:
	 *     (lib=[Library|ID] assignement=[Assignement|ID])
	 */
	protected void sequence_RefPartLib(ISerializationContext context, RefPartLib semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.REF_PART_LIB__LIB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.REF_PART_LIB__LIB));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.REF_PART_LIB__ASSIGNEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.REF_PART_LIB__ASSIGNEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefPartLibAccess().getLibLibraryIDTerminalRuleCall_0_0_1(), semanticObject.getLib());
		feeder.accept(grammarAccess.getRefPartLibAccess().getAssignementAssignementIDTerminalRuleCall_2_0_1(), semanticObject.getAssignement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns RefPart
	 *     RefPart returns RefPart
	 *
	 * Constraint:
	 *     variable_partie=[Assignement|ID]
	 */
	protected void sequence_RefPart(ISerializationContext context, RefPart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.REF_PART__VARIABLE_PARTIE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.REF_PART__VARIABLE_PARTIE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefPartAccess().getVariable_partieAssignementIDTerminalRuleCall_0_1(), semanticObject.getVariable_partie());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Rotate
	 *     Rotate returns Rotate
	 *
	 * Constraint:
	 *     (name='rotate' angleCST=EInt tempsCST=INT)
	 */
	protected void sequence_Rotate(ISerializationContext context, Rotate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.ROTATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.ROTATE__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.ROTATE__ANGLE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.ROTATE__ANGLE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.ROTATE__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.ROTATE__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotateAccess().getNameRotateKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRotateAccess().getAngleCSTEIntParserRuleCall_4_0(), semanticObject.getAngleCST());
		feeder.accept(grammarAccess.getRotateAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns TakeOff
	 *     TakeOff returns TakeOff
	 *
	 * Constraint:
	 *     name='takeoff'
	 */
	protected void sequence_TakeOff(ISerializationContext context, TakeOff semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.TAKE_OFF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.TAKE_OFF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTakeOffAccess().getNameTakeoffKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeGeneric returns TypeGeneric
	 *
	 * Constraint:
	 *     (name=ID elements+=Element elements+=Element*)
	 */
	protected void sequence_TypeGeneric(ISerializationContext context, TypeGeneric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns UP
	 *     DepZ_Impl returns UP
	 *     UP returns UP
	 *
	 * Constraint:
	 *     (name='up' distanceCST=INT tempsCST=INT)
	 */
	protected void sequence_UP(ISerializationContext context, UP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__DISTANCE_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__DISTANCE_CST));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.DEP_ZIMPL__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.DEP_ZIMPL__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUPAccess().getNameUpKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUPAccess().getDistanceCSTINTTerminalRuleCall_4_0(), semanticObject.getDistanceCST());
		feeder.accept(grammarAccess.getUPAccess().getTempsCSTINTTerminalRuleCall_7_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Movement returns Wait
	 *     Wait returns Wait
	 *
	 * Constraint:
	 *     (name='wait' tempsCST=INT)
	 */
	protected void sequence_Wait(ISerializationContext context, Wait semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.WAIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.WAIT__NAME));
			if (transientValues.isValueTransient(semanticObject, DrnPackage.Literals.WAIT__TEMPS_CST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DrnPackage.Literals.WAIT__TEMPS_CST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitAccess().getNameWaitKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWaitAccess().getTempsCSTINTTerminalRuleCall_4_0(), semanticObject.getTempsCST());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     With returns With
	 *
	 * Constraint:
	 *     (name='with' option+=RefDevice option+=RefDevice*)
	 */
	protected void sequence_With(ISerializationContext context, With semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
